import java.util.*;

public class Graph {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int num;
        // Строим матрицу смежности графа и указываем длину всех дуг

        /*
         * /
         * Wj = Wk + xk - lkj * g, где
         * Wk - начальное количест1во топлива в баке в начале маршрута из точки k в
         * точку
         * j;
         * xk - количество заправленного топлива в точке `k`
         * lkj - длина участка (k, j) ∈ E;
         * g – удельный расход топлива;
         * phi - количество полученного топлива в точке j.
         */

        double phi;

        int n = 9; // Количество вершин графа
        int m = 8; // Количество ребер графа

        int[] k = new int[] { 0, 0, 1, 2, 3, 3, 4, 5, 6 }; // откуда
        int[] j = new int[] { 1, 2, 3, 4, 5, 6, 6, 7, 7 }; // куда
        int[] l = new int[] { 20, 35, 55, 70, 60, 40, 100, 80, 30 }; // длина

        double W = 12; // объем бака
        double[] xk = new double[10];
        // double[] xk = new double[] { 5, 5, 1, 2, 5, 3, 10, 10, 15 }; // заправленное
        // топливо в точках
        double[] p = new double[] { 55, 55, 49.1, 61, 50, 49, 53, 52.5, 51 }; // цена за 1 литр
        double g = 0.1; // средний расход в литрах на 1 км, если 10л на 100км
        double[] w = new double[10]; // кол-во горючего в баке на предыщуй точке
        double[][] S = new double[10][10]; // общая сумма затраченного горючего при движении
        System.out.println("Какой алгоритм использовать?\n1 - прямой | 2 - обратный");
        num = in.nextInt();

        // Алгоритм из 0 в N с учетом ограничения W
        if (num == 1) {
            System.out.println("\nПрямой алгоритм:");
            for (int d = 0; d < n; d++) {
                if (l[d] > 0) {
                    // Вычисление необходимого количества топлива xk для данной точки
                    xk[d] = Math.min(W, l[d] * g);

                    S[k[d]][j[d]] = w[k[d]] + xk[d] - l[d] * g;
                    phi = xk[d] * p[d] + S[k[d]][j[d]];

                    System.out.println("Из " + k[d] + " в " + j[d] + " с расст. " + l[d] + " и ценой " + p[d]
                            + ": " + phi + " = " + xk[d] + " * " + p[d] + " + (" + w[k[d]] + " + "
                            + xk[d] + " - " + l[d] + " * " + g + ")");

                    if (d > 0 && j[d - 1] == j[d]) {
                        w[j[d]] = Math.min(w[j[d]], phi);
                        // w[j[d]] = Math.min(Math.min(w[j[d]], phi), W); // Применение ограничения на
                        // объем бака
                    } else {
                        w[j[d]] = phi;
                    }
                }
            }
        }

        // Алгоритм из N в 0 с учетом ограничения W
        if (num == 2) {
            System.out.println("\nОбратный алгоритм:");
            for (int d = n - 1; d >= 0; d--) {
                if (l[d] > 0) {
                    // Вычисление необходимого количества топлива xk для данной точки
                    xk[d] = Math.min(W, l[d] * g);

                    S[k[d]][j[d]] = w[k[d]] + xk[d] - l[d] * g;
                    phi = xk[d] * p[d] + S[k[d]][j[d]];

                    System.out.println("Из " + j[d] + " в " + k[d] + " с расст. " + l[d] + " и ценой " + p[d]
                            + ": " + phi + " = " + xk[d] + " * " + p[d] + " + (" + w[j[d]] + " + "
                            + xk[d] + " - " + l[d] + " * " + g + ")");

                    if (d < n - 1 && k[d + 1] == k[d]) {
                        w[k[d]] = Math.min(w[k[d]], phi);
                    } else {
                        w[k[d]] = phi;
                    }
                }
            }
        }
    }
}